// This is the backend code for reading and writing

// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using GameSparks.RT;
using GameSparks.RT.Pools;

namespace GameSparks.RT.Proto
{
    internal partial class Packet
    {
        /// <summary>Read the VarInt length prefix and the given number of bytes from the stream and deserialze it into the instance.</summary>
		internal static int DeserializeLengthDelimited(Stream stream, BinaryReader br ,Packet instance)
        {
            long limit = global::GameSparks.RT.Proto.ProtocolParser.ReadUInt32(stream);
			int origLimit = (int)limit;
            limit += stream.Position;
            while (true)
            {
                if (stream.Position >= limit)
                {
                    if (stream.Position == limit)
                        break;
                    else
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Read past max limit");
                }
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    throw new System.IO.EndOfStreamException();
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
					case 8:
						instance.OpCode = global::GameSparks.RT.Proto.ProtocolParser.ReadZInt32 (stream);
                        continue;
                    // Field 2 Varint
                    case 16:
                        instance.SequenceNumber = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
                        continue;
                    // Field 3 Varint
                    case 24:
                        instance.RequestId = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
                        continue;
                    // Field 5 Varint
                    case 40:
                        instance.Sender = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
                        continue;
                    // Field 6 Varint
                    case 48:
                        instance.Reliable = global::GameSparks.RT.Proto.ProtocolParser.ReadBool(stream);
                        continue;
                    // Field 14 LengthDelimited
					case 114:
						PooledObjects.PositionStreamPool.Pop ();
						try{
	                        if (instance.Data == null)
								instance.Data = RTData.ReadRTData(stream, br, instance.Data);
	                        else
								RTData.ReadRTData(stream, br, instance.Data);
	                        continue;
						}finally {

						}
                    // Field 15 LengthDelimited
                    case 122:
					instance.Payload = instance.ReadPayload(stream, origLimit);
                        continue;
                }

                var key = global::GameSparks.RT.Proto.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::GameSparks.RT.Proto.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

			return origLimit;
        }

        /// <summary>Serialize the instance into the stream</summary>
        internal static void Serialize(Stream stream, Packet instance)
        {
            // Key for field: 1, Varint
            stream.WriteByte(8);
            global::GameSparks.RT.Proto.ProtocolParser.WriteZInt32(stream, instance.OpCode);
            if (instance.SequenceNumber != null)
            {
                // Key for field: 2, Varint
                stream.WriteByte(16);
                global::GameSparks.RT.Proto.ProtocolParser.WriteUInt64(stream,(ulong)instance.SequenceNumber.Value);
            }
            if (instance.RequestId != null)
            {
                // Key for field: 3, Varint
                stream.WriteByte(24);
                global::GameSparks.RT.Proto.ProtocolParser.WriteUInt64(stream,(ulong)instance.RequestId.Value);
            }
            if (instance.TargetPlayers != null)
            {
                foreach (var i4 in instance.TargetPlayers)
                {
                    // Key for field: 4, Varint
                    stream.WriteByte(32);
                    global::GameSparks.RT.Proto.ProtocolParser.WriteUInt64(stream,(ulong)i4);
                }
            }
            if (instance.Sender != null)
            {
                // Key for field: 5, Varint
                stream.WriteByte(40);
                global::GameSparks.RT.Proto.ProtocolParser.WriteUInt64(stream,(ulong)instance.Sender.Value);
            }
            if (instance.Reliable != null)
            {
                // Key for field: 6, Varint
                stream.WriteByte(48);
                global::GameSparks.RT.Proto.ProtocolParser.WriteBool(stream, instance.Reliable.Value);
            }
            
            if(instance.Data != null ) { 
				stream.WriteByte(114); 
				RTData.WriteRTData(stream, instance.Data); 
			}
            instance.WritePayload(stream);
        }

        /// <summary>Helper: Serialize with a varint length prefix</summary>
        internal static int SerializeLengthDelimited(Stream stream, Packet instance)
        {
            MemoryStream ms = PooledObjects.MemoryStreamPool.Pop ();
            try
            {
                Serialize(ms, instance);        
#if __WINDOWS__
                byte[] data = ms.ToArray();      
                Array.Resize<byte>(ref data, ms.Capacity);
#else
                var data = ms.GetBuffer();
#endif
				long pos = ms.Position;
				global::GameSparks.RT.Proto.ProtocolParser.WriteUInt32(stream, (uint)ms.Position);
				stream.Write(data, 0, (int)ms.Position);
				return (int)ms.Position;
            }
            finally
            {
                PooledObjects.MemoryStreamPool.Push (ms);
            }
        }
    }

}
