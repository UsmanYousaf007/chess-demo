// This is the backend code for reading and writing

// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using GameSparks.RT.Pools;

namespace Com.Gamesparks.Realtime.Proto
{
    internal partial class LoginCommand
    {
        /// <summary>Serialize the instance into the stream</summary>
        internal static void Serialize(Stream stream, LoginCommand instance)
        {
            if (instance.Token != null)
            {
                // Key for field: 1, LengthDelimited
                stream.WriteByte(10);
                global::GameSparks.RT.Proto.ProtocolParser.WriteBytes(stream, Encoding.UTF8.GetBytes(instance.Token));
            }
			if (instance.ClientVersion != null)
			{
				// Key for field: 2, Varint
				stream.WriteByte(16);
				global::GameSparks.RT.Proto.ProtocolParser.WriteUInt64(stream,(ulong)instance.ClientVersion.Value);
			}
        }

        /// <summary>Helper: Serialize with a varint length prefix</summary>
        internal static void SerializeLengthDelimited(Stream stream, LoginCommand instance)
        {
            MemoryStream ms = PooledObjects.MemoryStreamPool.Pop ();
            try
            {
                Serialize(ms, instance);
#if __WINDOWS__
                var data = ms.ToArray(); 
#else
                var data = ms.GetBuffer();
#endif
                global::GameSparks.RT.Proto.ProtocolParser.WriteUInt32(stream, (uint)ms.Position);
                stream.Write(data, 0, (int)ms.Position);
            }
            finally
            {
                PooledObjects.MemoryStreamPool.Push (ms);
            }
        }
    }

    internal partial class LoginResult
    {
        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        internal static Com.Gamesparks.Realtime.Proto.LoginResult Deserialize(Stream stream, Com.Gamesparks.Realtime.Proto.LoginResult instance)
        {
            if (instance.ActivePeers == null)
                instance.ActivePeers = new List<int>();
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.Success = global::GameSparks.RT.Proto.ProtocolParser.ReadBool(stream);
                        continue;
                    // Field 2 LengthDelimited
                    case 18:
                        instance.ReconnectToken = global::GameSparks.RT.Proto.ProtocolParser.ReadString(stream);
                        continue;
                    // Field 3 Varint
                    case 24:
                        instance.PeerId = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
                        continue;
                    // Field 4 Varint
                    case 32:
                        // repeated
                        instance.ActivePeers.Add((int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream));
                        continue;
					// Field 5 Varint
					case 40:
						instance.FastPort = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
						continue;
                }

                var key = global::GameSparks.RT.Proto.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::GameSparks.RT.Proto.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

    }

    internal partial class PingCommand
    {
        /// <summary>Serialize the instance into the stream</summary>
        internal static void Serialize(Stream stream, PingCommand instance)
        {
        }

        /// <summary>Helper: Serialize with a varint length prefix</summary>
        internal static void SerializeLengthDelimited(Stream stream, PingCommand instance)
        {
            MemoryStream ms = PooledObjects.MemoryStreamPool.Pop ();
            try
            {
                Serialize(ms, instance);
#if __WINDOWS__
                var data = ms.ToArray(); 
#else
                var data = ms.GetBuffer();
#endif
                global::GameSparks.RT.Proto.ProtocolParser.WriteUInt32(stream, (uint)ms.Position);
                stream.Write(data, 0, (int)ms.Position);
            }
            finally
            {
                PooledObjects.MemoryStreamPool.Push (ms);
            }
        }
    }

    internal partial class PingResult
    {
        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        internal static Com.Gamesparks.Realtime.Proto.PingResult Deserialize(Stream stream, Com.Gamesparks.Realtime.Proto.PingResult instance)
        {
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                var key = global::GameSparks.RT.Proto.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::GameSparks.RT.Proto.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

    }

    internal partial class UDPConnectMessage
    {
        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        internal static Com.Gamesparks.Realtime.Proto.UDPConnectMessage Deserialize(Stream stream, Com.Gamesparks.Realtime.Proto.UDPConnectMessage instance)
        {
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                var key = global::GameSparks.RT.Proto.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::GameSparks.RT.Proto.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

        /// <summary>Serialize the instance into the stream</summary>
        internal static void Serialize(Stream stream, UDPConnectMessage instance)
        {
        }

        /// <summary>Helper: Serialize with a varint length prefix</summary>
        internal static void SerializeLengthDelimited(Stream stream, UDPConnectMessage instance)
        {
            MemoryStream ms = PooledObjects.MemoryStreamPool.Pop ();
            try
            {
                Serialize(ms, instance);
#if __WINDOWS__
                var data = ms.ToArray();
#else
                var data = ms.GetBuffer();
#endif
                global::GameSparks.RT.Proto.ProtocolParser.WriteUInt32(stream, (uint)ms.Position);
                stream.Write(data, 0, (int)ms.Position);
            }
            finally
            {
                PooledObjects.MemoryStreamPool.Push (ms);
            }
        }
    }

    internal partial class PlayerConnectMessage
    {
        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        internal static Com.Gamesparks.Realtime.Proto.PlayerConnectMessage Deserialize(Stream stream, Com.Gamesparks.Realtime.Proto.PlayerConnectMessage instance)
        {
            if (instance.ActivePeers == null)
                instance.ActivePeers = new List<int>();
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.PeerId = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
                        continue;
                    // Field 4 Varint
                    case 32:
                        // repeated
                        instance.ActivePeers.Add((int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream));
                        continue;
                }

                var key = global::GameSparks.RT.Proto.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::GameSparks.RT.Proto.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

    }

    internal partial class PlayerDisconnectMessage
    {
        /// <summary>Takes the remaining content of the stream and deserialze it into the instance.</summary>
        internal static Com.Gamesparks.Realtime.Proto.PlayerDisconnectMessage Deserialize(Stream stream, Com.Gamesparks.Realtime.Proto.PlayerDisconnectMessage instance)
        {
            if (instance.ActivePeers == null)
                instance.ActivePeers = new List<int>();
            while (true)
            {
                int keyByte = stream.ReadByte();
                if (keyByte == -1)
                    break;
                // Optimized reading of known fields with field ID < 16
                switch (keyByte)
                {
                    // Field 1 Varint
                    case 8:
                        instance.PeerId = (int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream);
                        continue;
                    // Field 4 Varint
                    case 32:
                        // repeated
                        instance.ActivePeers.Add((int)global::GameSparks.RT.Proto.ProtocolParser.ReadUInt64(stream));
                        continue;
                }

                var key = global::GameSparks.RT.Proto.ProtocolParser.ReadKey((byte)keyByte, stream);

                // Reading field ID > 16 and unknown field ID/wire type combinations
                switch (key.Field)
                {
                    case 0:
                        throw new global::GameSparks.RT.Proto.ProtocolBufferException("Invalid field id: 0, something went wrong in the stream");
                    default:
                        global::GameSparks.RT.Proto.ProtocolParser.SkipKey(stream, key);
                        break;
                }
            }

            return instance;
        }

    }

}
